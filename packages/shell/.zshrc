#!/usr/bin/env zsh

# Machine-local pre-configuration hook.
# Source ~/.local/.zshrc.pre.local if it exists. This allows machine-specific customizations
# to run before any shared dotfiles configuration, without modifying the shared dotfiles themselves.
[[ -f ~/.local/.zshrc.pre.local ]] && source ~/.local/.zshrc.pre.local

# Lazy-load plugin: sourced early so it's available throughout .zshrc.
# Installed by `just fetch-plugins`; see packages/shell/.local/bin/fetch-zsh-plugins.
[[ -f ~/.local/share/zsh/plugins/lazy-load.plugin.zsh ]] && source ~/.local/share/zsh/plugins/lazy-load.plugin.zsh

# If profiling shell startup, set ZSHRC_PROFILE.
# ZSHRC_PROFILE=1
if [[ -n "$ZSHRC_PROFILE" ]]; then
  set -o xtrace
  zmodload zsh/zprof
fi

if [ ! -f $HOME/.gitconfig_local ]; then
  >&2 echo "Configure your git user settings in $HOME/.gitconfig_local -- see ~/.gitconfig for template."
fi

# Homebrew and other binaries.
export PATH="/opt/homebrew/bin:$HOME/.local/bin:$PATH:/usr/bin"
export FPATH="/opt/homebrew/share/zsh/site-functions:$FPATH"

# NPMX. See the npmx script for more details.
export PATH="$PATH:$HOME/.npmx/bin"

# Load direnv.
eval "$(direnv hook zsh)"

# Use .localrc for SUPER SECRET STUFF that you don't want in your public, versioned repo.
[ -f $HOME/.localrc ] && source $HOME/.localrc

# Style.
# Only set starship prompt if starship is installed.
# Don't set it if TERM_PROGRAM matches values in STARSHIP_SKIP_TERMS (colon-separated list).
: ${STARSHIP_SKIP_TERMS:=""}
STARSHIP_SKIP_TERMS="$STARSHIP_SKIP_TERMS:vscode"
[[ ! ":$STARSHIP_SKIP_TERMS:" =~ ":$TERM_PROGRAM:" ]] && \
        type starship > /dev/null && eval "$(starship init zsh)"

# Opens the current shell with a minimal starship config set -- the prompt in there should be '$ '.
# Makes it easier to copy-and-paste clean output from the terminal to comms tools like Slack and GitHub.
alias dollar-prompt='STARSHIP_CONFIG=~/.config/dollarsign.starship.toml $SHELL'
# In theory you can just do this by executing
#
#   $ export STARSHIP_CONFIG=~/.config/dollarsign.starship.toml
#
# in the current shell. That's kind of a pain in the butt though; this makes it a command.

# zsh interaction configuration.
# Up and down search for commands starting with the current buffer, if anything's populated in that buffer.
bindkey '\e[A' history-beginning-search-backward
bindkey '\e[B' history-beginning-search-forward
# Not a fan of the "repeat last command" zsh builtin.
disable r
# But I *am* a fan of zmv.
autoload -U zmv
# Deletion with meta keys.
bindkey "^[[3~"  delete-char
bindkey "^[3;5~" delete-char

# Editor defaults.
export EDITOR=nvim
export VISUAL=nvim
alias e=$EDITOR

# Experimental: version management with asdf
# One-time setup: git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.13.1
[[ -f "$HOME/.asdf/asdf.sh" ]] && . "$HOME/.asdf/asdf.sh"
# Add completions to path. Has to happen before compinit.
[[ -d $HOME/.local/share/zsh/site-functions ]] && fpath=($HOME/.local/share/zsh/site-functions $fpath)
fpath=(${ASDF_DIR}/completions $fpath)
# One-time setup for the asdf-direnv plugin, per https://github.com/asdf-community/asdf-direnv:
#   asdf plugin-add direnv
#   asdf direnv setup --shell zsh --version system
# Source asdf-direnv's shell-init script, which is auto-generated by the above command script.
[[ -f "${XDG_CONFIG_HOME:-$HOME/.config}/asdf-direnv/zshrc" ]] && source "${XDG_CONFIG_HOME:-$HOME/.config}/asdf-direnv/zshrc"

# Completion.
# Don't autocorrect me.
unsetopt correct
unsetopt correct_all
# On slow systems, checking the cached .zcompdump file to see if it must be 
# regenerated adds a noticable delay to zsh startup.  This little hack restricts 
# it to once a day.  It should be pasted into your own completion file.
#
# The globbing is a little complicated here:
# - '#q' is an explicit glob qualifier that makes globbing work within zsh's [[ ]] construct.
# - 'N' makes the glob pattern evaluate to nothing when it doesn't match (rather than throw a globbing error)
# - '.' matches "regular files"
# - 'mh+24' matches files (or directories or whatever) that are older than 24 hours.
# via https://gist.github.com/ctechols/ca1035271ad134841284#gistcomment-3109177
#
# JW added bashcompinit as well, which is required for certain Python CLI tools, like pipx, that use
# `register-python-argcomplete`.
autoload -Uz compinit
autoload -U bashcompinit
() {
  setopt extendedglob local_options

  if [[ -n $HOME/.zcompdump(#qN.mh+24) ]]; then
    compinit
    bashcompinit
  else
    compinit -C
    bashcompinit -C
  fi
}
# Smart-ish-case completion -- lowercase letters match uppercase letters but not the other way around.
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
# If I type `git checkout ta<tab>`, autocomplete with local `task/*` branches, not with the million remote `task/...`
# branches.
export GIT_COMPLETION_CHECKOUT_NO_GUESS=1

# Command editing.
# This is the best. `ctrl-x e` opens a buffer in $EDITOR containing the current contents of the zsh buffer. Edit and
# exit to set the zsh buffer to the results of your editing. Via https://nuclearsquid.com/writings/edit-long-commands
# and https://blog.thecodewhisperer.com/permalink/edit-then-execute
autoload -U edit-command-line
zle -N edit-command-line
bindkey '^xe' edit-command-line
bindkey '^x^e' edit-command-line
# These command-editing tools can encourage a edit/execute loop for multiline commands. In those cases it's nice to be
# able to use comments.
setopt interactive_comments

# Initialize autojump (aka j).
[ -f /opt/homebrew/etc/profile.d/autojump.sh ] && . /opt/homebrew/etc/profile.d/autojump.sh

# For now, let's experiment with the no-plugins zsh experience.

# Languages.
# Go.
export PATH=$PATH:$(go env GOPATH)/bin
export GOPATH=$(go env GOPATH)
# Haskell.
[ -f $HOME/.ghcup/env ] && source $HOME/.ghcup/env
# Rust.
[ -f $HOME/.cargo/env ] && source $HOME/.cargo/env

# VS Code.
# ^a, ^e, and ^r should work in the VS Code terminal. The VS Code terminal will silently change editing mode based on
# the contents of EDITOR or VISUAL. We don't want that, so explicitly set it to Emacs mode.
# See https://github.com/microsoft/vscode-docs/issues/5221#issuecomment-1061081538.
bindkey -e

# SSH.
eval `ssh-agent`

# RipGrep.
export RIPGREP_CONFIG_PATH=$HOME/.config/ripgreprc
# Paged and pretty (colors, headers, and line numbers).
function rgp { rg -p $"@" | less -RFX }

# Dotfiles management: see ~/dotfiles/README.md

# General-purpose aliases.
#
# > The more time you spend with Unix, the more you realize how much the folks from Bell Labs hated typing.
# -- Dr. Drang, *Some `bc` stuff* (https://leancrew.com/all-this/2021/02/some-bc-stuff/)
alias g=git
alias pu=pueue
# Mnemonic: "paged fzf".
alias pzf="fzf --preview='less {}' --bind shift-up:preview-page-up,shift-down:preview-page-down"

# General-purpose functions.
#
# Creates a new scratch directory and cds to it
# via http://ku1ik.com/2012/05/04/scratch-dir.html
# README behavior by @mambocab.
function scratch {
  # ~/scratch is a symlink to the current scratch dir...
  cur_dir="$HOME/scratch"
  # ... which is named for the current date and time. (Altered from original impl, which used seconds since the Epoch
  # and was hard to read.)
  new_dir="$HOME/tmp/scratch-`date +%F_%H-%M-%S`"
  mkdir -p $new_dir
  ln -nfs $new_dir $cur_dir
  cd $cur_dir
  # Pipe all arguments into a README in case you ever want to figure out what this dir was for.
  [ $# -ne 0 ] && echo "$@" > README
  echo "New scratch dir ready for grinding ;>"
}
#
# mk and cd.
function mkcd { mkdir -p $1 && cd $1 }
#
# Gary Bernhardt's Selecta shortcuts.
# Run Selecta in the current working directory, appending the selected path, if
# any, to the current command, followed by a space.
function insert-selecta-path-in-command-line() {
    local selected_path
    # Print a newline or we'll clobber the old prompt.
    echo
    # Find the path; abort if the user doesn't select anything.
    # GRB's original: selected_path=$(fd -t f . | selecta) || return
    selected_path=$(fd -t f . | fzf) || return
    # Escape the selected path, since we're inserting it into a command line.
    # E.g., spaces would cause it to be multiple arguments instead of a single
    # path argument.
    selected_path=$(printf '%q' "$selected_path")
    # Append the selection to the current command buffer.
    eval 'LBUFFER="$LBUFFER$selected_path "'
    # Redraw the prompt since Selecta has drawn several new lines of text.
    zle reset-prompt
}
# Create the zle widget that runs the function.
zle -N insert-selecta-path-in-command-line
# By default, ^S freezes terminal output and ^Q resumes it. Disable that so
# that those keys can be used for...
unsetopt flowcontrol
# ... the newly created widget.
bindkey "^S" "insert-selecta-path-in-command-line"
#
# Via garybernhardt:
# By @ieure; copied from https://gist.github.com/1474072
#
# It finds a file, looking up through parent directories until it finds one.
# Use it like this:
#
#   $ ls .tmux.conf
#   ls: .tmux.conf: No such file or directory
#
#   $ ls `up .tmux.conf`
#   /Users/grb/.tmux.conf
#
#   $ cat `up .tmux.conf`
#   set -g default-terminal "screen-256color"
function up()
{
    local DIR=$PWD
    local TARGET=$1
    while [ ! -e $DIR/$TARGET -a $DIR != "/" ]; do
        DIR=$(dirname $DIR)
    done
    test $DIR != "/" && echo $DIR/$TARGET
}
#
# go-objdump colorizes and reformats output of `go tool objdump`
# - it inserts an empty line after unconditional control-flow modifying instructions (JMP, RET, UD2)
# - it colors calls/returns in green
# - it colors traps (UD2) in red
# - it colors jumps (both conditional and unconditional) in blue
# - it colors padding/nops in violet
# - it colors the function name in yellow
# - it unindent the function body
# via https://gist.github.com/CAFxX/332b425634f12ccbb7a1eef074da19bf
function go-objdump() {
    go tool objdump "$@" |
                gsed -E "
                        s/^  ([^\t]+)(.*)/\1  \2/
                        s,^(TEXT )([^ ]+)(.*),$(tput setaf 3)\\1$(tput bold)\\2$(tput sgr0)$(tput setaf 3)\\3$(tput sgr0),
                        s/((JMP|RET|UD2).*)\$/\1\n/
                        s,.*(CALL |RET).*,$(tput setaf 2)&$(tput sgr0),
                        s,.*UD2.*,$(tput setaf 1)&$(tput sgr0),
                        s,.*J[A-Z]+.*,$(tput setaf 4)&$(tput sgr0),
                        s,.*(INT \\\$0x3|NOP).*,$(tput setaf 5)&$(tput sgr0),
                        "
}

# Interactive history with atuin.
# One-time setup: brew install atuin
type atuin > /dev/null && eval "$(atuin init zsh)"

# ^t for fzf file-selection.
# Framework taken from https://github.com/junegunn/fzf/blob/master/shell/key-bindings.zsh
#
# FZF_CTRL_T_COMMAND can be customized to change the file-finding command. This one is from https://github.com/sharkdp/fd?tab=readme-ov-file#using-fd-with-fzf.
FZF_CTRL_T_COMMAND='fd --type file --follow --hidden --exclude .git'
__fzfcmd() {
  [ -n "${TMUX_PANE-}" ] && { [ "${FZF_TMUX:-0}" != 0 ] || [ -n "${FZF_TMUX_OPTS-}" ]; } &&
    echo "fzf-tmux ${FZF_TMUX_OPTS:--d${FZF_TMUX_HEIGHT:-40%}} -- " || echo "fzf"
}
__fzf_defaults() {
  # $1: Prepend to FZF_DEFAULT_OPTS_FILE and FZF_DEFAULT_OPTS
  # $2: Append to FZF_DEFAULT_OPTS_FILE and FZF_DEFAULT_OPTS
  echo "--height ${FZF_TMUX_HEIGHT:-40%} --bind=ctrl-z:ignore $1"
  command cat "${FZF_DEFAULT_OPTS_FILE-}" 2> /dev/null
  echo "${FZF_DEFAULT_OPTS-} $2"
}
__fzf_select() {
  setopt localoptions pipefail no_aliases 2> /dev/null
  local item
  FZF_DEFAULT_COMMAND=${FZF_CTRL_T_COMMAND:-} \
  FZF_DEFAULT_OPTS=$(__fzf_defaults "--reverse --walker=file,dir,follow,hidden --scheme=path" "${FZF_CTRL_T_OPTS-} -m") \
  FZF_DEFAULT_OPTS_FILE='' $(__fzfcmd) "$@" < /dev/tty | while read item; do
    echo -n "${(q)item} "
  done
  local ret=$?
  echo
  return $ret
}
fzf-file-widget() {
  LBUFFER="${LBUFFER}$(__fzf_select)"
  local ret=$?
  zle reset-prompt
  return $ret
}
if [[ "${FZF_CTRL_T_COMMAND-x}" != "" ]]; then
  zle     -N            fzf-file-widget
  bindkey -M emacs '^T' fzf-file-widget
  bindkey -M vicmd '^T' fzf-file-widget
  bindkey -M viins '^T' fzf-file-widget
fi


# Experimental: jabba Java version manager.
#
# Maybe this should be loaded on-demand or just used in .envrc files as necessary.
[ -s "/opt/homebrew/opt/jabba/share/jabba/jabba.sh" ] && . "/opt/homebrew/opt/jabba/share/jabba/jabba.sh"

# Experimental: local-only config versioning.
# One-time setup:
#   git init --bare ~/.localconf.git
#   localconf config --local status.showUntrackedFiles no
# As with the dotfiles alias, ~ becomes a worktree managed by git, with the repository itself managed in ~/.dotfiles.
# And we can run `git status` without git complaining that everything in your home dir isn't tracked.
alias localconf='git --git-dir=$HOME/.localconf.git --work-tree=$HOME'

if [[ -n "$ZSHRC_PROFILE" ]]; then
  zprof
fi

unsetopt BG_NICE

# Machine-local post-configuration hook.
# Source ~/.local/.zshrc.post.local if it exists. This allows machine-specific customizations
# to run after all shared dotfiles configuration, without modifying the shared dotfiles themselves.
[[ -f ~/.local/.zshrc.post.local ]] && source ~/.local/.zshrc.post.local
